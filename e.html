<h1 id="kooc">KOOC</h1>
<p><em>Groupe:</em> Kooc aracha</p>
<p><em>Projet:</em> KOOC – Kind of Objective C</p>
<p><em>Durée:</em> 2 mois</p>
<p><em>Membres:</em> Timothee Le Gal de Kerangal, Gabriel Amice, Olivier Faure, Camille Priou, Louis Antonini, Xavier Loire.</p>
<p>Le KOOC est un langage de programmation compilé vers le C. L'exécutable <code>kooc</code> prend en paramètre des noms de fichiers .kh et .kc, et crée des fichiers .h et .c en sortie. Par exemple, la commande <code>kooc foo.kh bar.kc</code> créera les fichiers <code>foo.h</code> et <code>bar.c</code>.</p>
<p>Le KOOC est un langage de programmation compilé vers le C. L'exécutable <code>kooc</code> prend en paramètre des fichiers de texte écrite en langage KOOC, analyse ces fichiers, et crée des fichiers correspondants en langage C, capables d'être lus par le compilateur <code>gcc</code>, et exécutant les tâches décrites dans les fichiers KOOC. Ce procédé, similaire aux origines du C++, permet de générer mécaniquement du code C ayant des propriétés étrangères au langages.</p>
<h2 id="les-fonctionnalités-du-kooc">Les fonctionnalités du KOOC</h2>
<p>Le langage KOOC a pour but d'implémenter les fonctionnalités de bases d'un langage orienté objet:</p>
<ul>
<li><p>Création d'espaces de nom (les modules)</p></li>
<li><p>Surcharge de fonctions</p></li>
<li><p>Création de types abstraits de données (ADT), possédant des méthodes et une durée de vie.</p></li>
<li><p>Système d'héritage, et d'héritage virtuel, permettant la création de collections hétérogènes</p></li>
</ul>
<h1 id="la-syntaxe-kooc">La syntaxe KOOC</h1>
<p>Les fonctionnalités du KOOC sont implémentées à travers une surcouche du C, ce qui signifie que tout code valide en C est également valide en KOOC. À l'inverse du C++, qui réutilise des constructions syntaxiques illégales en C et leur donne un sens nouveau, les instructions ajoutées par le KOOC utilisent leur propre syntaxe distincte du C.</p>
<p>Les principaux ajouts sont les instructions KOOC, prenant la forme <code>@nom_de_la_declaration args...</code> suivie ou non d'un bloc. Sauf précision contraire, ces instructions se trouvent dans le scope global et ne peuvent pas être positionnées dans un bloc, une structure, une fonction, etc. Chaque instruction KOOC est remplacée par une suite d'instructions C correspondante, et donne des informations supplémentaires au compilateur KOOC qui ne seront pas nécessairement ajoutées au fichier de sortie, mais seront utilisées pour des vérifications (ex: vérifier qu'un appel KOOC fait bien référence à un fonction déclarée plus haut). Le code C en dehors de ces instructions n'est pas modifié, à l'exception des appels KOOC (Voir Opérateur <code>[]</code>).</p>
<h2 id="linstruction-module">L'instruction module</h2>
<p>Syntaxe:</p>
<p><code>@module name_of_the_module { declarations... }</code></p>
<p>Cette instruction marque la définition du module <code>name_of_the_module</code>. Cette définition contient une suite de déclarations en C, qui seront ajoutées à l'espace de nom name_of_the_module. Un module ne peut pas être défini plusieurs fois avec le même nom.</p>
<p>Une définition de module peut contenir des déclarations de variables et de fonctions. Plusieurs variables et fonctions du même nom mais avec une signature différentes peuvent être déclarées. Lors de la conversion en C, leur nom sera décoré avec les informations de leur signature (Voir Décoration de symboles); ce mécanisme est nommé la surcharge de variable/fonction. La signature inclut le nom du module, le type d'une variable, le type de retour d'une fonction, et les types des arguments de la fonction. Si une variable ou fonction est déclarée comme étant statique, elle n'est pas déclarée dans le fichier en sortie.</p>
<p>Exemple:</p>
<pre><code>@module Universe
{
    int     THE_ANSWER = 42;
    char    THE_ANSWER = 42;

    int     return_the_answer();
}</code></pre>
<p>Deviendra:</p>
<p><code>extern int      _kooc_var_Universe_THE_ANSWER_int;</code> <code>extern char     _kooc_var_Universe_THE_ANSWER_char;</code></p>
<p><code>int             _kooc_func_Universe_return_the_answer_int_0();</code></p>
<p><em>NOTE:</em> Si une déclaration de type (ex: typedef, struct, enum, etc) est inclue dans un bloc de module, on peut imaginer plusieurs façon de la gérer: l'inclure dans le code C sans la décorer (et éventuellement inclure un warning), arrêter la compilation et afficher un message d'erreur, ou décorer la déclaration, et prévoir une syntaxe KOOC pour accéder au type. La seconde solution est celle qui demande le moins d'efforts; l'inconvénient de la première solution est qu'elle peut mener à des erreurs contre-intuitives, si deux types différents, mais ayant le même nom sont déclarés dans deux modules différents.</p>
<p><em>NOTE:</em> Il est possible que la définition d'un module accepte des implémentations de fonctions en plus des simples prototypes. Dans ce cas là, la déclaration de la fonction devrait être précédée du mot-clé <code>inline</code>; dans le cas contraire le compilateur pourra émettre une erreur ou un warning.</p>
<h2 id="linstruction-implementation">L'instruction implementation</h2>
<p>Syntaxe:</p>
<p><code>@implementation name_of_the_module { declarations... }</code></p>
<p>Cette instruction marque l'implémentation du module name_of_the_module. Il contient une suite de définitions de fonctions; chaque fonction inclue dans le bloc implementation doit avoir un prototype correspondant dans le bloc module. Les déclarations du bloc module qui impliquent une implémentation (ex: &quot;int x = 3;&quot;) sont implicitement implémentées dans le fichier .c correspondant au bloc module.</p>
<p>Chaque bloc module doit avoir au plus un bloc implementation correspondant. Dans la mesure où plusieurs fichiers peuvent être compilés séparément, chacun implémentant le même module, ce qui mènerait à des erreurs de linkage difficiles à comprendre, l'implémentation d'un module crée un symbole <code>_KOOC_nom_du_module_IMPLEMENTATION</code>, repérable dans les erreurs de linkage.</p>
<p>Exemple:</p>
<pre><code>@implementation Universe
{
    int         return_the_answer()
    {
        return 42;
    }
}</code></pre>
<p>Deviendra:</p>
<pre><code>`int      _KOOC_Universe_IMPLEMENTATION;`
`int      _kooc_var_Universe_THE_ANSWER_int = 42;`
`char     _kooc_var_Universe_THE_ANSWER_char = 42;`

`int      _kooc_func_Universe_return_the_answer_int_0()`
{
    return 42;
}</code></pre>
<p>NOTES: On peut imaginer une règle telle que les fonctions déclarées dans module, mais pas implémentées dans le bloc implementation déclencheraient un warning. On peut egalement imaginer un mot-clé <code>@implement_sup</code> qui contientrait des implémentations de fonctions déclarées dans le bloc module, mais n'incluerait pas d'implémentation implicite. Ce mot-clé permettrait de répartir l'implémentation d'un module sur plusieurs fichiers. Une autre solution pour pouvoir répartir l'implémentation sur plusieurs fichiers serait de ne pas mettre d'implémentation implicite dans le bloc implementation.</p>
<h2 id="linstruction-import">L'instruction import</h2>
<p>Syntaxe:</p>
<p><code>@import &quot;filename.kh&quot;</code></p>
<p>Cette instruction a deux effets: faire savoir au KOOC que les modules importés existent et sont appelables, et assurer l'inclusion par le code C compilé du contenu des modules/fichiers, en évitant les problèmes de double inclusion. Les instructions <code>@implementation</code> et les opérateurs [] ne sont pas valides si ils ne sont pas précédés par une inclusion du module correspondant.</p>
<p>Exemple:</p>
<pre><code>@import &quot;ThisTeamIsReallyGoodAndIShouldGiveThemAGoodGrade.kh&quot;</code></pre>
<p>Deviendra:</p>
<pre><code>#ifndef THISTEAMISREALLYGOODANDISHOULDGIVETHEMAGOODGRADE_H_
 #include &quot;ThisTeamIsReallyGoodAndIShouldGiveThemAGoodGrade.h&quot;
 #define THISTEAMISREALLYGOODANDISHOULDGIVETHEMAGOODGRADE_H_
#endif // !THISTEAMISREALLYGOODANDISHOULDGIVETHEMAGOODGRADE_H_</code></pre>
<p><em>NOTE:</em> Les fichiers .h générés par <code>kooc</code> sont automatiquement protégés contre la double inclusion, au cas où ils seraient inclus par un fichier C. Pour cette raison, la directive <code>#define</code> est placée après la directive <code>#include</code>.</p>
<p><em>NOTE:</em> Par défaut, le compilateur interprète l'addresse donnée comme étant relative au dossier du fichier compilé. Si le fichier <code>dir1/foo.kc</code> comprend une instruction <code>import &quot;subdir/bar.kh&quot;</code>, le compilateur cherchera le fichier à l'addresse <code>dir1/subdir/bar.kh</code>. Si le programme a été lancé avec un ou plusieurs arguments <code>-I dirname</code>, le compilateur essaie d'abord d'interpréter les addresse données par import comme étant relative à chacun des dossiers passés en argument, par ordre de passage.</p>
<h2 id="linstruction-class">L'instruction class</h2>
<p>Syntaxe:</p>
<p><code>@class ClassName { declarations... }</code></p>
<p>Cette instruction crée un espace de nom <code>ClassName</code>; les déclarations dans le bloc <code>class</code> sont traitées de la même façon que dans un bloc <code>module</code>. Le bloc de classe accepte également des déclarations <code>@member</code>, qui peuvent définir des variables ou des fonctions membres de <code>ClassName</code>. Lors de la compilation, une structure est créée, dont les champs sont les variables membres de la classe, et un typedef de cette structure est fait vers le nom de la classe.</p>
<p>Les fonctions membres d'une classe sont strictement équivalentes à des fonctions de modules, avec un argument supplémentaire de type <code>ClassName*</code>. Une fonction membre <code>int foobar(int x)</code> est une fonction non-membre <code>int foobar(ClassName* self, int x)</code> peuvent être appelées de la même façon, et ont la même signature; la seule exception à cette règle est le cas des fonctions membres virtuels (Voir Méthodes virtuelles).</p>
<p>L'implémentation des méthodes d'une classe se fait à l'aide du mot-clé <code>@implementation</code>, qui accepte également des déclarations <code>@member</code>.</p>
<p>Pour un exemple de création de classe, voir <code>examples/StackInt.*</code>.</p>
<p>Syntaxe <code>@member</code>:</p>
<p><code>@member declaration</code></p>
<p><code>@member { declarations... }</code></p>
<p><em>NOTE:</em> Les variables membres sont également appelées attributs, et les fonctions membres sont également appelées méthodes.</p>
<h2 id="fonctions-spéciales">Fonctions spéciales</h2>
<p>Les fonctions suivantes ont une sémantique propre dans le contexte d'une classe: <code>init</code>, <code>alloc</code>, <code>new</code>, <code>clean</code>, et <code>delete</code>.</p>
<h3 id="les-fonctions-init-alloc-et-new">Les fonctions <code>init</code>, <code>alloc</code> et <code>new</code></h3>
<p>La méthode <code>init</code> est un constructeur, et doit être appelée à l'instanciation d'une classe. En écrivant une classe, le codeur peut définir autant de méthodes nommées <code>init</code> qu'il le souhaite, en utilisant les mécanismes de surcharge de fonction. Si aucun constructeur n'est défini, le KOOC en génère un par défaut, qui initialise tous les champs soit à zéro, soit à leur valeur indiquée dans la déclaration; par exemple, si un attribut est déclaré sous la forme <code>@member int x = 333</code>, alors le constructeur par défaut initialisera la valeur de x à 333. Il est possible d'accéder au constructeur par défaut depuis un autre constructeur avec la syntaxe <code>[super init]</code> (Voir Résolution de types).</p>
<p>La fonction non-membre <code>alloc</code> est générée automatiquement pour chaque classe. Elle alloue un bloc de mémoire de la taille de la classe, et est équivalente à <code>malloc(sizeof(ClassName))</code>. La fonction non-membre <code>new</code> est générée automatiquement, et appelle la fonction <code>alloc</code>, puis la fonction <code>init</code>. Le KOOC génère autant de surcharges de la fonction <code>new</code> qu'il y a de surcharges de la fonction <code>init</code>. Essayer de surcharger <code>alloc</code> ou <code>new</code> déclenche une erreur.</p>
<h3 id="les-méthodes-clean-et-delete">Les méthodes <code>clean</code> et <code>delete</code></h3>
<p>La méthode <code>clean</code> est optionnellement écrite par l'utilisateur, et ne doit prendre aucun paramètre. Cette méthode est le destructeur de la classe, et doit libérer les ressources allouées par une instance. La méthode <code>delete</code> appelle la méthode <code>clean</code> si elle existe, puis libère l'espace mémoire de l'objet. Essayer de surcharger <code>delete</code> déclenche une erreur.</p>
<p>Si une classe est codée sans destructeur, mais possède des attributs qui en ont un, alors un destructeur est automatiquement généré; ce destructeur appelle simplement les destructeur de chacun des attributs de l'instance.</p>
<p>Lorsqu'une classe possédant un destructeur est instanciée dans une fonction, le destructeur de l'instance est automatiquement appelé juste avant la fin de la portée de cette classe.</p>
<p>Exemple:</p>
<pre><code>int foobar()
{
    MyClass abc;

    ...
    return 0;
}</code></pre>
<p>Deviendra:</p>
<pre><code>int foobar()
{
    MyClass abc;

    ...
    MyClass_clean_void_MyClass_ptr(&amp;abc);
    return 0;
}</code></pre>
<h2 id="opérateur">Opérateur <code>[]</code></h2>
<p>Syntaxes:</p>
<p><code>[Foobar.varname]</code></p>
<p><code>@!(type_name)[Foobar.varname]</code></p>
<p><code>[Foobar funcname : arg1 : arg2 : ...]</code></p>
<p><code>@!(type1)[Foobar funcname : arg1 : @!(type2)arg2 : ...]</code></p>
<p>L'opérateur <code>[]</code>, ou appel KOOC, permet d'accéder aux fonctions et variables d'un module ou d'une classe à l'intérieur d'une instruction C.</p>
<p>L'appel <code>[Foobar.varname]</code> récupère la variable <code>varname</code> définie dans l'espace de nom <code>Foobar</code>, qui peut être un module ou une classe. Si l'espace de nom possède plusieurs surcharges de la variable <code>varname</code>, la variable récupérée est celle ayant le type attendu par l'appel. Ce type est inféré par le compilateur en fonction du contexte entourant l'appel (par exemple, <code>int x = [Foobar.varname]</code> recupèrera la surcharge de <code>var</code> de type <code>int</code>); il peut également être précisé par l'utilisateur avec la syntaxe <code>@!(type_name)[Foobar.varname]</code>. Si le type de l'appel n'est pas précisé, et il est impossible de le déduire du contexte, alors la compilation s'arrête sur une erreur (Voir Résolution de types).</p>
<p>L'appel <code>[Foobar funcname]</code> récupère la fonction sans arguments <code>funcname</code> de l'espace de nom <code>Foobar</code>. L'appel <code>[Foobar funcname : arg1 : arg2]</code> récupère la fonction <code>funcname</code> à deux arguments. L'appel <code>@!(type1)[Foobar funcname : arg1 : @!(type2)arg2]</code> précise en plus le type de retour et le type du second argument attendus. (Voir Résolution de types)</p>
<p>Si l'appel KOOC est situé dans le corps de l'implémentation d'une fonction membre, alors il donne une sémantique spéciale aux identifiants <code>self</code> et <code>super</code>. L'id <code>self</code> est interprété comme un pointeur sur l'instance appelante de la classe, et l'id <code>super</code> comme étant un pointeur sur cette même instance, interprété comme étant du type parent (Voir Héritage).</p>
<p>A la compilation, l'appel KOOC est remplacé par l'expression C correspondante; dans le cas d'un appel de variable, le nom décoré de la variable; dans le cas d'un appel de fonction, le nom décoré de la fonction, avec ses arguments.</p>
<p>Exemple:</p>
<p><code>int var = @!(long)[Algo greatest : @!(long *)my_array : 10];</code></p>
<p>Deviendra:</p>
<pre><code>`int var = _kooc_func_Algo_greatest_long_2_arg_long_arg_Pint(my_array, 10);`</code></pre>
<p><em>NOTE:</em> Dans le cas où une variable et une fonction sont déclarées avec le même nom, il est possible d'accéder à la variable, ou à la fonction, selon la syntaxe utilisée. Il est en revanche impossible d'accéder à l'addresse de la fonction; ce problème pourrait être résolu en ajoutant une syntaxe (ex: <code>[Module.&amp;funcame]</code>) récupérant spécifiquement l'addresse d'une fonction.</p>
<h3 id="la-syntaxe-orientée-objet">La syntaxe orientée objet</h3>
<p>Syntaxes:</p>
<p><code>[object.varname]</code></p>
<p><code>[object funcname : args...]</code></p>
<p>Ces deux syntaxes sont valides seulement si <code>object</code> est un pointeur sur une classe qui possède un membre <code>funcname</code>/<code>varname</code>.</p>
<p>La première syntaxe est équivalente à <code>object-&gt;mangled_varname</code>, où <code>mangled_varname</code> correspond au nom décoré de <code>varname</code>, selon les mêmes règles que pour un appel de variable non membre.</p>
<p>La second syntaxe a deux sémantiques différentes. Si <code>funcname</code> est une méthode non virtuelle, alors cette syntaxe est strictement équivalente à <code>[ClassName funcname : object : args...]</code>, où <code>ClassName</code> est le type de <code>object</code>. Si <code>funcname</code> est une méthode virtuelle, alors cette syntaxe n'appelle pas la fonction définie dans l'espace de nom <code>ClassName</code>, mais la fonction correspondante, à l'addresse de la table virtuelle de <code>object</code>. (Voir Méthodes virtuelles)</p>
<p><em>NOTE:</em> Par défaut, ces syntaxes n'acceptent qu'un nom de variable de type <code>ClassName *</code>. Cette approche a l'avantage d'être simple à implémenter, et ne laisser aucune confusion possible. Cependant, elle manque de flexibilité, et oblige le programmeur à déclarer un pointeur pour chaque cas où l'adresse de <code>object</code> est calculée, ce qui ne permet pas des raccourcis simples comme <code>[&amp;object.varname]</code>. La solution la plus simple pour ce problème est de rajouter un cas spécial pour <code>&amp;object</code>. Une autre solution serait d'autoriser object à être n'importe quelle expression ayant pour type <code>ClassName *</code>; cette solution serait plus complexe à implémenter, et créerait des cas où l'interprétation d'une instruction serait visuellement ambiguë. Une autre solution serait de créer une syntaxe spécifique, et non ambiguë, pour la gestion d'une instance d'objet.</p>
<h2 id="héritage">Héritage</h2>
<p>Syntaxe:</p>
<p><code>class ClassName(ParentName) { declarations... }</code></p>
<p>Cette syntaxe permet de faire hériter <code>ClassName</code> d'une classe <code>ParentName</code> précédemment définie. On dit que <code>ClassName</code> est la classe fille de <code>ParentName</code>, et que <code>ParentName</code> est la classe parente de <code>ClassName</code>. Tous les attributs et les méthodes de <code>ParentName</code> sont accessibles depuis <code>ClassName</code>. Par exemple, si <code>ParentName</code> possède une méthode <code>foo()</code> et un attribut <code>bar</code>, alors <code>[ClassName foo : obj]</code> et <code>[obj.bar]</code> sont des appels valides si <code>obj</code> est de type <code>ClassName *</code>. Une fois compilé en code C, la première variable stockée dans la structure <code>ClassName</code> est une instance de <code>ParentName</code>; cela permet d'utiliser un pointeur sur <code>ClassName</code> comme étant un pointeur sur <code>ParentName</code>.</p>
<p>En plus de l'identifiant <code>super</code>, une méthode <code>super</code> sans arguments est générée automatiquement dans la classe fille, qui renvoie l'instance appelante typée comme étant de la classe parente.</p>
<p>Pour un exemple d'utilisation d'héritage, voir <code>examples/Inheritance.*</code> et <code>examples/main.*</code>.</p>
<h3 id="méthodes-virtuelles">Méthodes virtuelles</h3>
<p>Syntaxe:</p>
<p><code>@virtual declaration</code></p>
<p>Exemple:</p>
<p><code>@member @virtual int foobar();</code></p>
<p>Le mot-clé <code>@virtual</code> signale qu'une méthode est virtuelle. Lorsqu'une classe a au moins une méthode virtuelle, une table virtuelle, ou vtable, est générée pour cette classe. La vtable est une structure contenant des pointeurs sur chaque méthode virtuelle de la classe. Des instances de cette structure sont créées pour la classe et chacune de ses classes filles. Si une méthode est redéfinie dans une classe fille, alors le pointeur sur fonction correspondant dans l'instance de la vtable de la classe fille pointera sur la méthode redéfinie. La mot clé <code>@virtual</code> ne peut être placé que dans un bloc de classe; il ne peut pas être placé dans un bloc d'implémentation.</p>
<p>L'appel d'une méthode virtuelle peut se faire de deux façons différentes. La syntaxe <code>[ClassName foobar : object : args...]</code> fait directement appel à la méthode définie dans l'espace de nom <code>ClassName</code>, et n'utilise pas la vtable. La syntaxe <code>[object foobar : args...]</code>, en revanche, fait appel à la fonction à l'addresse pointée par l'attribut <code>foobar</code> de la vtable de <code>object</code>; cette syntaxe est équivalente à <code>object-&gt;vtable-&gt;foobar_with_mangling(object, args...)</code>, et appelle la méthode correspondant au type réel de <code>object</code>, et non le type de sa référence.</p>
<p>Si une classe a au moins une méthode virtuel, alors son destructeur est automatiquement déclaré comme étant virtuel. Cela permet par exemple de stocker des collections de pointeurs sur une classe parente, et, a la destruction de cette collection, d'appeller tous les destructeurs des classes filles réelles des objets de la collections.</p>
<p>Déclarer un constructeur, un attribut ou une fonction non-membre comme étant virtuel est une erreur de compilation.</p>
<p><em>NOTE:</em> On peut prévoir un cas particulier où la syntaxe <code>[&amp;obj func : args]</code> est utilisée, et <code>obj</code> est une variable de type <code>ClassName</code>; dans ce cas, le type de <code>&amp;obj</code> serait connu à la compilation et l'utilisation de la vtable pourrait être omise.</p>
<h1 id="fonctionnement-du-compilateur">Fonctionnement du compilateur</h1>
<p>Le projet entier est codé en Python. L'exécutable <code>kooc</code> prend en paramètre des chemins de fichiers ayant les extensions .kh et .kc et contenant du code KOOC, traduit ce code en code C pour chaque fichier, et crée des fichiers .h et .c correspodants en sortie.</p>
<p>Par exemple, la commande</p>
<p><code>kooc foo.kh bar.kc</code></p>
<p>Créera les fichiers</p>
<p><code>foo.h bar.c</code>.</p>
<p>L'exécutable peut également prendre en paramètre des arguments sous la forme <code>-I dirname</code>, qui ajoutent des addresses de dossier à partir desquels chercher les directives <code>@import</code> (Voir L'instruction import).</p>
<h2 id="étapes-de-compilation">Étapes de compilation</h2>
<p>La compilation de chaque fichier est séparée en plusieurs étapes, ou passes. Chaque passe transforme l'état des données du fichier en un objet lisible par la passe suivante, jusqu'à ce que le code KOOC soit transformé en code C. Les ressources utilisées par chaque passe sont détaillées dans les sections à venir. Les passes sont les suivantes:</p>
<ul>
<li><p>Parser le fichier KOOC. Cette passe transforme le texte au format KOOC en un AST KOOC (Voir L'arbre généré). Elle doit aussi lister tous les types et les objets déclarés dans le fichier, et les fichiers qu'il importe.</p></li>
<li><p>Remplacer les appels KOOC par des instructions C. Cette passe parcours l'AST KOOC, et transforme chaque appel KOOC (syntaxe <code>[]</code>) en une instruction C correspondante, en résolvant les types de l'appel et en appliquant la décoration de symboles.</p></li>
<li><p>Transformer chaque déclaration KOOC en déclarations C. Cette passe transforme l'AST KOOC en un AST C lisible par CNorm. Elle parcourt l'AST et remplace chaque déclaration KOOC par une liste de déclarations C, en décorant les symboles et en appliquant des règles spécifiques à chaque déclaration (Voir La Syntaxe KOOC).</p></li>
<li><p>Transformer l'AST C en code C. Cette passe est un simple appel à la méthode <code>to_c</code> de CNorm.</p></li>
</ul>
<p>Pour plus de détails sur les passes du compilateur, voir <code>Compiling_FAST.pdf</code>.</p>
<h2 id="le-parsing">Le parsing</h2>
<p>Le parsing est fait avec les modules CNorm et (indirectement) Pyrser. L'arbre de syntaxe est généré par une classe <code>KoocParser</code>, dans le module éponyme, qui hérite de la classe <code>Declaration</code> de CNorm et de ses méthodes <code>parse</code> et <code>parse_file</code>. La classe <code>KoocParser</code> définit la syntaxe du KOOC, sous forme d'une BNF Pyrser identique à celle présente dans le fichier <code>KOOC_Syntax.bnf</code>, et de hooks contruisant l'AST des déclarations et appels KOOC.</p>
<p>Les hooks de <code>KoocParser</code> doivent également construire une liste de types et d'objets à utiliser pour la résolution d'appels KOOC (Voir Résolution de types).</p>
<h2 id="larbre-généré">L'arbre généré</h2>
<p>La méthode <code>parse()</code> de <code>KoocParser</code> renvoit un objet <code>Node</code>. Cet objet a un attribut <code>types</code>, qui est une liste de types déclarés dans le fichier compilé, un attribut <code>objects</code> et un attribut <code>body</code>, qui est une liste mixte de déclarations C, et de déclarations KOOC, et qui correspond à la liste des déclarations du fichier. Une déclaration KOOC peut être un des objets suivants:</p>
<pre><code>KoocImport
    filename    : str

KoocModule
    name        : str
    fields      : List&lt;cnorm.nodes.Decl&gt;

KoocClass
    name        : str
    fields      : List&lt;cnorm.nodes.Decl&gt;
    members     : List&lt;KoocMember&gt;

    KoocMember
        isVirtual   : bool
        decl        : cnorm.nodes.Decl

KoocImplem
    name        : str
    fields      : List&lt;cnorm.nodes.Decl&gt;        &gt;&gt; Implémentations de fonctions</code></pre>
<p>Le parseur peut également trouver des appels KOOC à l'intérieur des expressions C. Ces appels KOOC sont stockés à l'intérieur des AST de déclarations C sous la forme suivante:</p>
<pre><code>KoocCall
    target      : str || cnorm.nodes.Expr       &gt;&gt; Espace de nom ou instance de classe
    name        : str
    isFunc      : bool
    args        : None || List&lt;cnorm.nodes.Expr&gt;</code></pre>
<h2 id="décoration-de-symboles">Décoration de symboles</h2>
<p>Le langage KOOC permet la surcharge de variables et de fonctions. Deux modules différents peuvent posséder une variable du même nom, et un module peut posséder deux variables du même nom mais de types différents, et ces variables produiront des symboles lisibles par un compilateur C. Ceci est accompli à travers la décoration de symbole: chaque objet déclaré dans un module ou une classe KOOC voit son nom changé, pour produire un nom unique dans le code C résultant. Ce code est obtenu en ajoutant au du texte obtenu à partir de la signature de la variable/fonction.</p>
<p>La signature d'un objet inclut son type (variable ou fonction), l'espace de nom dans lequel il se trouve, son type de retour, et ses arguments. Les symboles sont décorés selon le format suivant:</p>
<p><code>_kooc_var_NAMESPACE_VARNAME_TYPE</code> <code>_kooc_func_NAMESPACE_FUNCNAME_RETURNTYPE_0</code> <code>_kooc_func_NAMESPACE_FUNCNAME_RETURNTYPE_ARGCOUNT[_arg_ARGTYPE]*</code></p>
<p>Dans ce format, TYPE, ARGTYPE et RETURNTYPE font référence à des chaines décrivant un type. Ces chaines sont les suivantes:</p>
<table>
<colgroup>
<col width="75%" />
<col width="24%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Type</th>
<th align="left">Chaine correspondante</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">char</td>
<td align="left">char</td>
</tr>
<tr class="even">
<td align="left">signed char</td>
<td align="left">schar</td>
</tr>
<tr class="odd">
<td align="left">unsigned char</td>
<td align="left">uchar</td>
</tr>
<tr class="even">
<td align="left">short &amp;&amp; short int &amp;&amp; signed short &amp;&amp; signed short int</td>
<td align="left">short</td>
</tr>
<tr class="odd">
<td align="left">unsigned short &amp;&amp; unsigned short int</td>
<td align="left">ushort</td>
</tr>
<tr class="even">
<td align="left">int &amp;&amp; signed &amp;&amp; signed int</td>
<td align="left">int</td>
</tr>
<tr class="odd">
<td align="left">unsigned &amp;&amp; unsigned int</td>
<td align="left">uint</td>
</tr>
<tr class="even">
<td align="left">long &amp;&amp; long int &amp;&amp; signed long &amp;&amp; signed long int</td>
<td align="left">long</td>
</tr>
<tr class="odd">
<td align="left">unsigned long &amp;&amp; unsigned long int</td>
<td align="left">ulong</td>
</tr>
<tr class="even">
<td align="left">long long &amp;&amp; long long int &amp;&amp; signed long long &amp;&amp; signed long long int</td>
<td align="left">llong</td>
</tr>
<tr class="odd">
<td align="left">unsigned long long &amp;&amp; unsigned long long int</td>
<td align="left">ullong</td>
</tr>
<tr class="even">
<td align="left">float</td>
<td align="left">float</td>
</tr>
<tr class="odd">
<td align="left">double</td>
<td align="left">double</td>
</tr>
<tr class="even">
<td align="left">long double</td>
<td align="left">ldouble</td>
</tr>
<tr class="odd">
<td align="left">TYPENAME*</td>
<td align="left">PTYPENAME</td>
</tr>
<tr class="even">
<td align="left">TYPENAME[42]</td>
<td align="left">A42TYPENAME</td>
</tr>
<tr class="odd">
<td align="left">struct TYPENAME</td>
<td align="left">STYPENAME</td>
</tr>
<tr class="even">
<td align="left">enum TYPENAME</td>
<td align="left">ETYPENAME</td>
</tr>
<tr class="odd">
<td align="left">union TYPENAME</td>
<td align="left">UTYPENAME</td>
</tr>
</tbody>
</table>
<p>La décoration d'un type déclaré par un typedef est la même que celle du type originel. La décoration d'un type pointeur sur fonction est la suivante:</p>
<p><code>FRETURNTYPE_ARGCOUNT[_arg_ARGTYPE]*</code></p>
<p>La signature d'un objet ne change pas qu'il soit ou non déclaré comme étant statique, inline, constant, volatile, ou extern. Ainsi, la déclarations suivante est une erreur de compilation:</p>
<pre><code>@module M
{
    static int x;
    const int x;
}</code></pre>
<p>Des exemples de décorations de symboles se trouvent dans les fichiers de traduction dans <code>examples/*.c examples/*.h</code>.</p>
<p><em>NOTE:</em> Ces fichiers d'exemples ayant été écrits à la main et non mécaniquement, il est possible que certains des décorations dans ces fichiers soient invalides.</p>
<h2 id="résolution-de-types">Résolution de types</h2>
<p>La surcharge de variables/fonctions implique une ambiguité possible lors des appels KOOC. Par exemple, dans le code suivant:</p>
<pre><code>@module Foobar
{
    int x;
    char x;
}

int fbx = [Foobar.x];</code></pre>
<p>L'appel <code>[Foobar.x]</code> correspond-il à la première ou la seconde déclaration de <code>x</code>? Cette ambiguité peut être résolu par un précision manuelle des types attendus (Voir Opérateur []), ou par une résolution à la compilation des types. Dans l'exemple précédent, <code>Foobar.x</code> est assigné à un <code>int</code>, le compilateur peut donc en déduire que la variable attendue est celle déclarée dans <code>Foobar</code> comme étant un <code>int</code>.</p>
<p>L'algorithme de résolution de types pour un appel <code>[Foobar.func : args...]</code> est le suivant:</p>
<ul>
<li><p>Si l'appel KOOC est situé dans une opération (ex: <code>[Foobar.func : args...] + 3</code>), l'agorithme est appliqué à cette opération.</p></li>
<li><p>Une liste de toutes les fonctions <code>func</code> dans le module <code>Foobar</code> ayant le nombre d'arguments de <code>args...</code> est faite.</p></li>
<li><p>Les types de renvoi ou d'arguments précisés par l'utilisateur sont fixés. Les fonctions n'ayant pas ces types de renvoi / d'arguments sont éliminées de la liste.</p></li>
<li><p>Si l'appel KOOC est situé dans une assignation (ex: <code>int fbx = [Foobar.x];</code>), le type de renvoi est fixé.</p></li>
<li><p>Pour chaque argument dans <code>arg</code>, une liste de types de retour possibles est générée. Si l'argument est une expression C, on tente de déterminer son type. Si l'argument est un appel KOOC, cet algorithme lui est appliqué pour générer la liste, avec comme contrainte que le type de retour de l'appel KOOC doit être un des types acceptés en paramètre par la les fonctions <code>func</code> restantes.</p></li>
<li><p>Les fonctions dont au moins un argument n'est pas dans la liste de retours possibles sont supprimées de la liste. Si la liste a été réduite, on ré-applique l'étape précédente.</p></li>
<li><p>La liste des fonctions restantes est renvoyée. Si cette liste n'est pas composée d'un seul élément, et l'appel de cet algorithme n'est pas récursif, alors le type de la fonction est ambigu, et une erreur de compilation est déclenchée.</p></li>
</ul>
<p><em>NOTE:</em> Cet algorithme part du principe que les types sont comparables seulement en termes d'égalité/inégalité, et ne prend pas en compte les conversions implicites ou l'héritage. On peut concevoir un algorithme plus complexe qui classerait les types par ordre de conversion (par exemple, int est convertible en long, mais pas l'inverse), et ajouter des passes supplémentaires pour en tenir compte. Cependant, l'agorithme présent répond aux besoins de base du projet.</p>
